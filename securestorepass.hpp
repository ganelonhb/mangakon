#ifndef SECURESTOREPASS_HPP
#define SECURESTOREPASS_HPP

/* The securestorepass module will handle everything related to storing and retrieveing a password stored in a plaintext on the disk.
 * in ~/.config/mangakon/secure, there should be a file called usr.toml.
 * user.toml includes the following KVPs: user, pass, key, secret.
 * pass and secret should be encrypted in a file found in a file called ~/.config/mangakon/.shadow/secrets
 * secrets contains three values:
 * The hash for the user.toml file,
 * The key for pass,
 * and the key for secret.
 * If the file does not exist, it is generated by spawning an apikeygamestate.
 * if the file does not contain all the keys, it does the same thing with fields autopopulated.
 * if the file does not have the same hash, but all the keys exist, then a new encryption is generated for the keys and values (unless block_encrypt = true)
 * otherwise, we just initialize as usual. Everything should happen in the constructor.
 */

#include <filesystem>

#include <tomlplusplus/toml.hpp>

#include "utils.hpp"

class SecureStorePass {
public:
    explicit SecureStorePass() {
        generate();
    }

    inline bool generate() {
        // TODO: Make cross platform
        std::string path = util::dirs::get_home() + "/.config";

        if (!std::filesystem::exists(path))
            std::filesystem::create_directory(path);
        else if (!std::filesystem::is_directory(path))
            return false;

        return true;
    }

    std::wstring user() const { return m_user; }
    std::wstring password() const { return m_password; }
    std::wstring apikey() const { return m_apikey; }
    std::wstirng secret() const { return m_secret; }

    bool block_encrypt() const { return m_block_encrypt; }

    std::wstring get_json() const { return L""; }

private:

    std::wstring m_user;
    std::wstring m_password;
    std::wstring m_apikey;
    std::wstring m_secret;

    bool m_block_encrypt;
}

#endif
